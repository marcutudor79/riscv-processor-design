\documentclass{article}
\usepackage{graphicx}                            % Required for inserting images
\usepackage{booktabs}                            % Required for tables
\usepackage[a4paper, total={6in, 8in}]{geometry} % Adjust page margins
\usepackage{hyperref}                            % Clickable links
\usepackage{array}
\usepackage{multirow}
\usepackage{longtable}
\usepackage{xcolor}
\usepackage{tabularx}
\usepackage{colortbl}
\usepackage{adjustbox}
\usepackage{float}
\usepackage{listings}
\usepackage{framed}
\usepackage[nobreak=true]{mdframed}
\usepackage{pdflscape}


\title{Project 1 Exectuion Platforms}
\author{Hamden Brini, Wilches Juan, Barau Elena, Marculescu Tudor}
\date{January 2025}

\begin{document}

\maketitle

\section{Introduction to RISC-V Instruction Set Architecture}

\hspace*{1em} In this section we are focusing on a decomposition of RISC-V hex instruction into the ASM instruction.
The instruction format is determined based on the opcode, funct3 and funct7 fields. Table 1 depicts a
detailed translation of each instruction from it's hex code to it's format fields. Some of them
not used in certain instruction types, and are marked with a dash (-) in the table. The ultimate factor
that determines the instruction type is the "Type" column, which indicates instruction format label
R, I, S or SB.

\subsection{Program Instructions Decomposition}
\begin{table}[H]
\raggedright
\label{tab:instruction-decomposition}
\vspace{0.3cm}
\renewcommand{\arraystretch}{2}
\begin{adjustbox}{width=\textwidth, center}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|}
\hline
\rowcolor{blue!20}
\textbf{Address} & \textbf{Hex Code} & \textbf{Opcode (6:0)} & \textbf{rd (11:7)} & \textbf{funct3 (14:12)} & \textbf{rs1 (19:15)} & \textbf{rs2 (24:20)} & \textbf{funct7 (31:25)} & \textbf{imm[11:0] (31:20)} & \textbf{imm[11:5] (31:25)} & \textbf{imm[4:0] (11:7)} & \textbf{Type} \\
\hline
0x0  & 0x00050893 & 0010011 & 10001 & 000 & 01010 & - & - & 000000000000 & - & - & I \\
0x4  & 0x00068513 & 0010011 & 01010 & 000 & 01101 & - & - & 000000000000 & - & - & I \\
0x8  & 0x04088063 & 1100011 & - & 000 & 10001 & 00000 & - & - & 0000010 & 00000 & SB \\
0xc  & 0x04058263 & 1100011 & - & 000 & 01011 & 00000 & - & - & 0000010 & 00100 & SB \\
0x10 & 0x04060063 & 1100011 & - & 000 & 01100 & 00000 & - & - & 0000010 & 00000 & SB \\
0x14 & 0x04d05063 & 1100011 & - & 101 & 00000 & 01101 & - & - & 0000010 & 00000 & SB \\
0x18 & 0x00088793 & 0010011 & 01111 & 000 & 10001 & - & - & 000000000000 & - & - & I \\
0x1c & 0x00269713 & 0010011 & 01110 & 001 & 01101 & - & - & 000000000010 & - & - & I \\
0x20 & 0x00e888b3 & 0110011 & 10001 & 000 & 10001 & 01110 & 0000000 & - & 0000000 & 10001 & R \\
0x24 & 0x0007a703 & 0000011 & 01110 & 010 & 01111 & - & - & 000000000000 & - & - & I \\
0x28 & 0x0005a803 & 0000011 & 10000 & 010 & 01011 & - & - & 000000000000 & - & - & I \\
0x2c & 0x01070733 & 0110011 & 01110 & 000 & 01110 & 10000 & 0000000 & - & 0000000 & 01110 & R \\
0x30 & 0x00e62023 & 0100011 & - & 010 & 01100 & 01110 & - & - & 0000000 & 00000 & S \\
0x34 & 0x00478793 & 0010011 & 01111 & 000 & 01111 & - & - & 000000000100 & - & - & I \\
0x38 & 0x00458593 & 0010011 & 01011 & 000 & 01011 & - & - & 000000000100 & - & - & I \\
0x3c & 0x00460613 & 0010011 & 01100 & 000 & 01100 & - & - & 000000000100 & - & - & I \\
0x40 & 0xff1792e3 & 1100011 & - & 001 & 01111 & 10001 & - & - & 1111111 & 00101 & SB \\
0x44 & 0x00008067 & 1100111 & 00000 & 000 & 00001 & - & - & 000000000000 & - & - & I \\
0x48 & 0xfff00513 & 0010011 & 01010 & 000 & 00000 & - & - & 111111111111 & - & - & I \\
0x4c & 0x00008067 & 1100111 & 00000 & 000 & 00001 & - & - & 000000000000 & - & - & I \\
0x50 & 0xfff00513 & 0010011 & 01010 & 000 & 00000 & - & - & 111111111111 & - & - & I \\
0x54 & 0x00008067 & 1100111 & 00000 & 000 & 00001 & - & - & 000000000000 & - & - & I \\
\hline
\end{tabular}
\end{adjustbox}
\caption{Decomposition of Hex Codes to RISC-V Instruction Format}
\end{table}

\hspace*{1em} A point to note is that the immediate fields for UJ and U type instructions are missing from Table 1.
This is because the provided program is missing them. There is also an overlap between the immediates
of S and SB type instructions, as they share the same positions in the instruction format. The table
head includes just the immediate fields for S out of simplicty, but in the case of SB, they were calculated
as depicted in the RISC-V specification from the Project 1 description \cite{PR1-SE201-21}.

\begin{table}[H]
\centering
\label{tab:instructions-simple}
\vspace{0.3cm}
\renewcommand{\arraystretch}{1.6} % Increases row height for all rows
\begin{tabular}{|c|c|c|c|}
\hline
\rowcolor{blue!20}
\textbf{Address} &
\textbf{Hex Code} &
\textbf{ASM Instruction (ABI)} &
\textbf{ASM Instruction (x-registers)} \\
\hline
0x0  & 0x00050893 & addi a7, a0, 0     & addi x17, x10, 0 \\
0x4  & 0x00068513 & addi a0, a3, 0     & addi x10, x13, 0 \\
0x8  & 0x04088063 & beq a7, zero, 64   & beq  x17, x0, 64 \\
0xc  & 0x04058263 & beq a1, zero, 68   & beq  x11, x0, 68 \\
0x10 & 0x04060063 & beq a2, zero, 64   & beq  x12, x0, 64 \\
0x14 & 0x04d05063 & bge zero, a3, 64   & bge  x0, x13, 64 \\
0x18 & 0x00088793 & addi a5, a7, 0     & addi x15, x17, 0 \\
0x1c & 0x00269713 & slli a4, a3, 2     & slli x14, x13, 2 \\
0x20 & 0x00e888b3 & add  a7, a7, a4    & add  x17, x17, x14 \\
0x24 & 0x0007a703 & lw   a4, 0(a5)     & lw   x14, 0(x15) \\
0x28 & 0x0005a803 & lw   a6, 0(a1)     & lw   x16, 0(x11) \\
0x2c & 0x01070733 & add  a4, a4, a6    & add  x14, x14, x16 \\
0x30 & 0x00e62023 & sw   a4, 0(a2)     & sw   x14, 0(x12)   \\
0x34 & 0x00478793 & addi a5, a5, 4     & addi x15, x15, 4   \\
0x38 & 0x00458593 & addi a1, a1, 4     & addi x11, x11, 4   \\
0x3c & 0x00460613 & addi a2, a2, 4     & addi x12, x12, 4   \\
0x40 & 0xff1792e3 & bne a5, a7, -28    & bne  x15, x17, -28 \\
0x44 & 0x00008067 & jalr zero, ra, 0   & jalr x0, x1, 0     \\
0x48 & 0xfff00513 & addi a0, zero, -1  & addi x10, x0, -1   \\
0x4c & 0x00008067 & jalr zero, ra, 0   & jalr x0, x1, 0     \\
0x50 & 0xfff00513 & addi a0, zero, -1  & addi x10, x0, -1   \\
0x54 & 0x00008067 & jalr zero, ra, 0   & jalr x0, x1, 0     \\
\hline
\end{tabular}
\caption{RISC-V Instructions with register numbers, symbolic names and addresses}
\end{table}

In order to better understand the provided program, Table 2 is introduced to map the hex codes with
their corresponding assembly instructions. As an overall view, the program is making use of RV32I instruction
set only. The registers are represented in both their symbolic names (ABI) and x-register numbers.
in order to facilitate the understanding of the program.

\subsection{Branch Delay Slot Concept}
\hspace*{1em} The branch delay slot concept is interesting when discussing pipelined processors. Esentially, when
a branch instruction is taken, the instructions that were fetched after the branch instructions become
invalid if there is no branch prediction. To avoid this, the branch delay slot declares that the instruction immediately following
a branch instruction is always executed, regardless of whether the branch is taken or not. This helps to
mitigate the performance penalty associated with branch instructions that invalidate subsequent instructions
in the pipeline. As explained in \cite{Stack-overflow-branch-delay}: "The idea of the branch shadow or delay
slot is to recover a part of the clocks. If you declare that the instruction after a branch is always
executed then when a branch is taken, then the instruction in the decode slot also gets executed, while
the instruction in the fetch slot is discarded. Therefore one has a hole of time not two." The branch
delay slot will be filled with an instruction that is independent of the branch outcome by the compiler
in the compilation phase of the program. It will look in a window of instructions before and after the
branch instruction to find a suitable candidate that will come right after it.

In terms of advantages and disadvantages, there are several points to consider.

For disadvantages:

\begin{itemize}

\item Branch delay slots may create complications in code debugging, since the instruction in the delay slot
might have side effects, it may lead to an unexpected state of the registers and memory.

\item It adds to the waiting time when trying to execute interruptions, since they will be deffered until
the delay slot instruction is executed. This is a problem in the case of real time systems.

\item Software compatibility requirements dictate that an architecture may not change the number of delay
slots from one generation to the next. This inevitably requires that newer hardware implementations
contain extra hardware to ensure that the architectural behaviour is followed despite no longer being relevant.
\end{itemize}

Advantages of using branch delay slots include:

\begin{itemize}

\item Improved performance in pipelined architectures, since it helps to reduce the number of pipeline
stalls caused by branch instructions if no branch prediction is used.

\item The use of branch delay slots helps simplify processor design by removing the need for sophisticated
branch prediction mechanisms in early architectures. As a result, the hardware becomes easier and less
expensive to implement.

\end{itemize}

Nowadays, the branch delay slot concept bacame obsolete, as modern processors use branch prediction
techniques to mitigate the braching performance penalty. This also mitigates the complications of
having the compiler finding suitable instructions to fill the delay slots.

\subsection{Branch Instructions Analysis}
\hspace*{1em} In order to understand better the provided program, it is useful to check the branch instructions and
where they lead to.

\begin{table}[H]
\centering
\label{tab:instructions-simple}
\vspace{0.3cm}
\renewcommand{\arraystretch}{1.6} % Increases row height for all rows
\begin{tabular}{|c|c|l|}
\hline
\rowcolor{blue!20}
\textbf{Address} & \textbf{Conditional branch} & \textbf{Branch to} \\
\hline

0x08 & beq a7, zero, 64  & 0x48: addi a0, zero, -1 \\
0x0c & beq a1, zero, 68  & 0x50: addi a0, zero, -1 \\
0x10 & beq a2, zero, 64  & 0x50: addi a0, zero, -1 \\
0x14 & bge zero, a3, 148 & 0x54: jalr zero, ra, 0  \\
0x40 & bne a5, a7, -28   & 0x24: lw a4, 0(a5)      \\

\hline
\end{tabular}
\caption{RISC-V Instructions with Addresses}
\end{table}

From the table above we can see that there are 4 first conditional branches, that being the
addresses 0x08, 0x0c, 0x10 and 0x14, which resemble input value checks. Considering the calling
convention for RISC-V, the registers a0-a7 are used for passing function arguments from the caller
to the callee. In this case, the supposition of input value checks is valid. The first three jump
to a return -1 in case the input values are 0, while the fourth one jumps to a return with the number
of elements to be processed, which would be less than or equal to 0.

The last conditional branch at address 0x40 is part of a loop. It checks whether the address stored
in register a5, used as a counter, is equal to the last address to be processed, which is stored in
register a7. If they are not equal, the program branches back to address 0x24 to continue processing
the next elements. If they are equal, the program continues to the return instruction.

\subsection{Program Functionality}

\hspace*{1em} The program can be divided into three main parts: input validation, processing loop, and return value.
The input validation part checks if any of the first three caller arguments are 0. The arguments are
passed are actually pointers to the input and output arrays, so they are checked if they are null,
which would indicate an invalid memory access, therefore leading to a jump to the section of the
program corresponding to return -1. The fourth argument is the number of elements to be processed,
which is checked in the register a3 to see if it is less than or equal to 0. In case it is, the program
jumps to the section corresponding to return, with the number of elements to be processed.

The processing loop starts at address 0x18 and continues until the branch instruction at address 0x40
It consists of an initial setup for the loop counter in register a5 and for the final value of the
counter, which is stored in register a7. Register a7 will store the address of the last element to be processed from
one of the input arrays, calculated as the base address plus the number of elements multiplied by 4,
the size of each element. Because the elements are 4 bytes long, it can be extrapolated that the arrays
are made of 32-bit integers. The loop itself consists of loading the elements from both input arrays,
by using registers a5 and a1, which store the current addresses of the elements. Afterwards, the elements
are summed and stored in register a4, which is then stored in the output array location pointed by register a2.
Finally, the addresses in registers a5, a1 and a2 are incremented by 4 to point to the next elements
to be processed. The loop continues until the address in register a5 is equal to the address in register a7.
This is ensured by the branch if not equal instruction at address 0x40.

Finally, the return part is reached at address 0x44, where the program jumps back to the calle, using
the address stored in register ra. The return value is stored in register a0, which is equal to the
number of elements to be processed.

\begin{table}[H]
\centering
\label{tab:instructions-simple}
\vspace{0.3cm}
\renewcommand{\arraystretch}{1.6} % Increases row height for all rows
\begin{tabular}{|c|c|l|}
\hline
\rowcolor{blue!20}
\textbf{Scenario} & \textbf{Return value} \\
\hline

input pointers are null & -1 \\
number of elements to be processed $\leq$ 0 & number of elemnts to be processed \\
processing finished and the result is ready & number of processed elements      \\

\hline
\end{tabular}
\caption{Return values of the program}
\end{table}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% SECTION 2 RISC-V Tool Chain

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{RISC-V Tool Chain}

\subsection {Reimagined C Code}
\hspace*{1em} The above explanation of the program's functionality allows us to reimagine the C code that could
have generated the assembly instructions that were previously described. To do so, one can have an
intuition on what certain assembly instructions would mean. For example, for the part of input
validation, the conditinal branches checks can be equivalent to the if statements of C language.

\begin{mdframed}

    \hspace*{1em} beq a7, zero, 64

    \dots

    addi a0, zero, -1

    jalr zero, ra, 0 $ \longrightarrow $   if (in1 == NULL) return -1;
\end{mdframed}

There is no direct connection between the register names and C variables, therefore arbitrary names
can be assigned to them based on their usage. For example, register a0 can be assigned to the variable
"in1", register a1 to "in2", register a2 to "out" and register a3 to "n", representing the two input
arrays, the output array and the number of elements to be processed from the arrays.

For the processing loop, one can reimagine it as a do while loop, iterating from 0 to n-1. This is
reflected in the assembly instructions which first setup the counter and the final conditional branch
to check if it has reached its final value.

\begin{framed}

    addi a5, a7, 0

    slli a4, a3, 2

    add a7, a7, a4

    \dots

    bne a5, a7, -28 $ \longrightarrow $   in1\_end = in1 + sizeof(int)*n; do \{ \dots \} while (in1 != in1\_end);
\end{framed}

As for the operations inside the loop, the lw can be mapped to array accesses in C, the add instruction
to the assignment operator and the sw to the assignment operator as well.

\begin{framed}
    lw a4, 0(a5)

    lw a6, 0(a1)

    add a4, a4, a6

    sw a4, 0(a2) $ \longrightarrow $   out[i] = in1[i] + in2[i];
\end{framed}

Therefore, taking into account all of the above observations, a complete C functions that could have
generated the provided assembly instructions is represented below:

\begin{lstlisting}[language=C, numbers=left, stepnumber=1, numbersep=5pt]
int addv(int *in1,int *in2,int *out,int n)
{
    if (in1 == NULL)
        return -1;
    if (in2 == NULL)
        return -1;
    if (out == NULL)
        return -1;
    if (n <= 0)
        return n;

    int* in1_end = in1 + sizeof(int)*n;
    do {
        *out = *in1 + *in2;
        in1++;
        in2++;
        out++;
    }
    while (in1 != in1_end);
    return n;
}
\end{lstlisting}

\subsection{Compiling the C Code to RISC-V Assembly}
By using the RISC-V GCC toolchain, one can compile the above C code into RISC-V object code and then
dissasemble it to obtain the assembly instructions. The following command was used in order to produce
the object file "se201-prog.o" from the C source file "se201-prog.c":

\begin{framed}
riscv64-linux-gnu-gcc -g -O0 -mcmodel=medlow -mabi=ilp32 -march=rv32im -Wall -c -o se201-prog.o se201-prog.c
\end{framed}

A fair mention is that in order to have a compilible C program, one needs to provide a main function as
an entry point. In it, the input arrays and the output array are defined, along with the number of
elements to be processed. The call to the addv function, which was seen previously, is also made in
main.


\begin{lstlisting}[language=C, numbers=left, stepnumber=1, numbersep=5pt]
int main() {
    int n = 50;
    int a[50] = {0};
    int b[50] = {0};
    int result[50] = {0};

    addv(a, b, result, n);
    return 0;
}
\end{lstlisting}

\subsection{Comparison between the generated and the previous instructions}

After succefully compiling the C code, one can dissasemble it to obtain the assembly instructions.
The following command is used to do so:

\begin{framed}
riscv64-linux-gnu-objdump -d ./se201-prog.o
\end{framed}

Then, because the addv function is the one of interest, we can navigate to the corresponding part
of the output, containing the label "addv". Below is a snippet of the generated assembly instructions
for it:

Generated Assembly Instructions:
\begin{lstlisting}
00000000 <addv>:
   0:   fd010113                addi    sp,sp,-48
   4:   02812623                sw      s0,44(sp)
   8:   03010413                addi    s0,sp,48
   c:   fca42e23                sw      a0,-36(s0)
  10:   fcb42c23                sw      a1,-40(s0)
  14:   fcc42a23                sw      a2,-44(s0)
  18:   fcd42823                sw      a3,-48(s0)
  1c:   fdc42783                lw      a5,-36(s0)
  20:   00079663                bnez    a5,2c <.L2>
  24:   fff00793                li      a5,-1
  28:   0980006f                j       c0 <.L3>

0000002c <.L2>:
  2c:   fd842783                lw      a5,-40(s0)
  30:   00079663                bnez    a5,3c <.L4>
  34:   fff00793                li      a5,-1
  38:   0880006f                j       c0 <.L3>

0000003c <.L4>:
  3c:   fd442783                lw      a5,-44(s0)
  40:   00079663                bnez    a5,4c <.L5>
  44:   fff00793                li      a5,-1
  48:   0780006f                j       c0 <.L3>

0000004c <.L5>:
  4c:   fd042783                lw      a5,-48(s0)
  50:   00f04663                bgtz    a5,5c <.L6>
  54:   fd042783                lw      a5,-48(s0)
  58:   0680006f                j       c0 <.L3>

0000005c <.L6>:
  5c:   fd042783                lw      a5,-48(s0)
  60:   00479793                slli    a5,a5,0x4
  64:   fdc42703                lw      a4,-36(s0)
  68:   00f707b3                add     a5,a4,a5
  6c:   fef42623                sw      a5,-20(s0)

00000070 <.L7>:
  70:   fdc42783                lw      a5,-36(s0)
  74:   0007a703                lw      a4,0(a5)
  78:   fd842783                lw      a5,-40(s0)
  7c:   0007a783                lw      a5,0(a5)
  80:   00f70733                add     a4,a4,a5
  84:   fd442783                lw      a5,-44(s0)
  88:   00e7a023                sw      a4,0(a5)
  8c:   fdc42783                lw      a5,-36(s0)
  90:   00478793                addi    a5,a5,4
  94:   fcf42e23                sw      a5,-36(s0)
  98:   fd842783                lw      a5,-40(s0)
  9c:   00478793                addi    a5,a5,4
  a0:   fcf42c23                sw      a5,-40(s0)
  a4:   fd442783                lw      a5,-44(s0)
  a8:   00478793                addi    a5,a5,4
  ac:   fcf42a23                sw      a5,-44(s0)
  b0:   fdc42703                lw      a4,-36(s0)
  b4:   fec42783                lw      a5,-20(s0)
  b8:   faf71ce3                bne     a4,a5,70 <.L7>
  bc:   fd042783                lw      a5,-48(s0)

000000c0 <.L3>:
  c0:   00078513                mv      a0,a5
  c4:   02c12403                lw      s0,44(sp)
  c8:   03010113                addi    sp,sp,48
  cc:   00008067                ret
\end{lstlisting}

By comparing the generated assembly with the one provided in the first section, one can observe that
several differences exist. Firstly, the compiler saves the function arguments on the stack before
using them, that being a0, a1, a2 and a3. Then it loads them back from the stack to perform the checks.

Secondly, the check for null pointers, which can be observed in the section from 0x20 -- 0x48 is done
using the "bnez" instruction instead of a "beq", which instead of jumping to a common return -1, they
jump over the return -1 instructions to the next check. This leads to a larger code size and is
also less efficient. The efficiency problem arises from the fact that if bnez is taken, when the pointer
is valid, then the processor will have to flush the pipeline, if no branch prediction is used.

Thirdly, the loop structure is different, as it can be seen in the 0x5c -- 0xb8 section. To compute
the end address of the processing loop, the program first takes out of the stack the value of a3, shifts
it by 4 then adds it to the address of the first element of the array, taken out of the stack as well.
It stores the result back on the stack. In the given assembly, this is done using only three instructions,
without using the stack at all. The same phenomenon can be observed for the loop body, in which each
each element is taken out of the stack, for example the address of the first input array element, which
is used to load the element, then the adress of the second input array element is taken out of the stack
to load the element. They are added and then the address of the output array element is taken out of the
stack to store the result. Finally, the addresses of the of the three arrays can be retaken out of the stack,
incremented by 4 and stored back on the stack.

Finally, the return part is similar, with the difference that actually a ret instruction is used instead
of jalr zero, ra, 0.

\subsection{Changing the Optimization Level}
By switching the optimization level from -O0 to -O, the generated assembly code changes significatly.
It is observed that the code size is reduced, and the loop starts to resemble more the code provided
in the first section. Below is a snippet of the generated assembly instructions:

\begin{lstlisting}
00000000 <addv>:
   0:   00050793                mv      a5,a0
   4:   00068513                mv      a0,a3

00000008 <.LVL1>:
   8:   02078e63                beqz    a5,44 <.L4>
   c:   04058063                beqz    a1,4c <.L5>
  10:   04060263                beqz    a2,54 <.L6>
  14:   04d05263                blez    a3,58 <.L2>
  18:   00469893                slli    a7,a3,0x4
  1c:   011788b3                add     a7,a5,a7

00000020 <.L3>:
  20:   0007a703                lw      a4,0(a5)
  24:   0005a803                lw      a6,0(a1)
  28:   01070733                add     a4,a4,a6
  2c:   00e62023                sw      a4,0(a2)
  30:   00478793                addi    a5,a5,4
  34:   00458593                addi    a1,a1,4

00000038 <.LVL4>:
  38:   00460613                addi    a2,a2,4

0000003c <.LVL5>:
  3c:   fef892e3                bne     a7,a5,20 <.L3>
  40:   00008067                ret

00000044 <.L4>:
  44:   fff00513                li      a0,-1
  48:   00008067                ret

0000004c <.L5>:
  4c:   fff00513                li      a0,-1

00000050 <.LVL8>:
  50:   00008067                ret

00000054 <.L6>:
  54:   fff00513                li      a0,-1

00000058 <.L2>:
  58:   00008067                ret
\end{lstlisting}

Firstly, the stack usage is eliminated completely and the function arguments are used directly from
the registers. Secondly, the input validation part is more efficient, as it uses beqz instructions
that jump directly to the return -1 section. The same phenomenon happens where a5 and a7 are used
as loop counter and address of the last element to be processed, respectively. This version of code
is very similar to the one provided in the first section, with only minor differencces in the return
sections, that use li instead of addi and ret instead of jalr zero, ra, 0.

Changes in code size occur as well when switching to higher optimization levels, such as -O3.

\begin{lstlisting}
00000000 <addv>:
   0:   00050793                mv      a5,a0
   4:   04050063                beqz    a0,44 <.L8>
   8:   02058e63                beqz    a1,44 <.L8>
   c:   02060c63                beqz    a2,44 <.L8>
  10:   00469893                slli    a7,a3,0x4
  14:   011508b3                add     a7,a0,a7
  18:   02d05263                blez    a3,3c <.L5>

0000001c <.L4>:
  1c:   0007a703                lw      a4,0(a5)
  20:   0005a803                lw      a6,0(a1)
  24:   00478793                addi    a5,a5,4

00000028 <.LVL2>:
  28:   00458593                addi    a1,a1,4

0000002c <.LVL3>:
  2c:   01070733                add     a4,a4,a6
  30:   00e62023                sw      a4,0(a2)

00000034 <.LVL4>:
  34:   00460613                addi    a2,a2,4

00000038 <.LVL5>:
  38:   fef892e3                bne     a7,a5,1c <.L4>

0000003c <.L5>:
  3c:   00068513                mv      a0,a3
  40:   00008067                ret

00000044 <.L8>:
  44:   fff00513                li      a0,-1

00000048 <.LVL7>:
  48:   00008067                ret
\end{lstlisting}

Here there are no more output sections that esentially do the same thing, such as in the -O version,
in which the li a0, -1 and ret instructions were repeated three times. The instructions are also
reordered slightly, but the overall structure remains the same.

\section {RISC-V Architecture}

\hspace*{1em} For the following part, a simple RISC-V processor is assumed. It consists of 5 stages (IF, ID, EX, MEM, WB).
The registers are read in the ID stage and written in the WB stage. The MEM stage is used for load and store,
but the address is computed in the EX stage. Data hazards between a memory load and another instruction
immediately using its result is resolved by stalling the ID stage.

The branches are performed in EX stage. The two instruction following a branch is flushed when the
branch is taken. For the arithmetic instructions forwarding is performed in order to reduce stalls.
That means that the result from the EX stage is forwarded back to the EX stage inputs when needed
by the next instruction.

\subsection {Program Flow}

\hspace*{1em} The program flow for the provided program is described in the following table. The table provides a
brief explanation of what happens in the processor and program state. At first the processor has the
registers a0, a1 and a2 set to value 0x200. Regiter a3 has the value 0x2, and all the other registers
are set to 0.

The memory contents at the addresses 0x200 through 0x210 is given as follows:
\begin{table}[H]
\centering
\label{tab:instructions-simple}
\vspace{0.3cm}
\renewcommand{\arraystretch}{1.6} % Increases row height for all rows
\begin{tabular}{|c|c|}
\hline
\rowcolor{blue!20}
\textbf{Address} & \textbf{Value} \\
\hline

0x200 & 0x61 \\
0x204 & 0x20 \\
0x208 & 0x62 \\
0x20C & 0x00 \\
0x210 & 0x00 \\
\hline
\end{tabular}
\caption{Initial memory contents}
\end{table}

\begin{landscape}
\begin{table}[H]
\raggedright
\vspace{0.3cm}
\renewcommand{\arraystretch}{2}
\begin{adjustbox}{width=\textwidth, center}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|}
\hline
\rowcolor{blue!20}
\textbf{PC} & \textbf{Instruction} & \textbf{a0} & \textbf{a1} & \textbf{a2} & \textbf{a3} & \textbf{a4} & \textbf{a5} & \textbf{a6} & \textbf{a7} & \textbf{Explanation} \\
\hline
0x0  & addi a7, a0, 0    & 0x200        & 0x200          & 0x200          & 0x2 & 0x0           & 0x0            & 0x0           & \textbf{0x200} & Copy value of a0 into a7 \\
0x4  & addi a0, a3, 0    & \textbf{0x2} & 0x200          & 0x200          & 0x2 & 0x0           & 0x0            & 0x0           & 0x200          & Copy value of a3 into a0 \\
0x8  & beq a7, zero, 64  & 0x2          & 0x200          & 0x200          & 0x2 & 0x0           & 0x0            & 0x0           & 0x200          & Branch not taken, PC goes to 0xc  \\
0xc  & beq a1, zero, 68  & 0x2          & 0x200          & 0x200          & 0x2 & 0x0           & 0x0            & 0x0           & 0x200          & Branch not taken, PC goes to 0x10 \\
0x10 & beq a2, zero, 64  & 0x2          & 0x200          & 0x200          & 0x2 & 0x0           & 0x0            & 0x0           & 0x200          & Branch not taken, PC goes to 0x14 \\
0x14 & bge zero, a3, 64  & 0x2          & 0x200          & 0x200          & 0x2 & 0x0           & 0x0            & 0x0           & 0x200          & Branch not taken, PC goes to 0x18 \\
0x18 & addi a5, a7, 0    & 0x2          & 0x200          & 0x200          & 0x2 & 0x0           & \textbf{0x200} & 0x0           & 0x200          & Copy value of a7 into a5 \\
0x1c & slli a4, a3, 2    & 0x2          & 0x200          & 0x200          & 0x2 & \textbf{0x8}  & 0x200          & 0x0           & 0x200          & Multiply value of a3 by 4, store it in a4 \\
0x20 & add a7, a7, a4    & 0x2          & 0x200          & 0x200          & 0x2 & 0x8           & 0x200          & 0x0           & \textbf{0x208} & Fast forward a4 and add it to a7 \\
0x24 & lw a4, 0(a5)      & 0x2          & 0x200          & 0x200          & 0x2 & \textbf{0x61} & 0x200          & 0x0           & 0x208          & Load value of address stored in a5, to a4 \\
0x28 & lw a6, 0(a1)      & 0x2          & 0x200          & 0x200          & 0x2 & 0x61          & 0x200          & \textbf{0x61} & 0x208          & Load value of address stored in a1, to a6 \\
0x2c & add a4, a4, a6    & 0x2          & 0x200          & 0x200          & 0x2 & 0x61          & 0x200          & \textbf{0xC2} & 0x208          & Double the value stored in a4 \\
0x30 & sw a4, 0(a2)      & 0x2          & 0x200          & 0x200          & 0x2 & 0x61          & 0x200          & 0xC2          & 0x208          & Store 0xC2 at 0x200 in memory \\
0x34 & addi a5, a5, 4    & 0x2          & 0x200          & 0x200          & 0x2 & 0x61          & \textbf{0x204} & 0xC2          & 0x208          & Add 0x4 to a5 \\
0x38 & addi a1, a1, 4    & 0x2          & \textbf{0x204} & 0x200          & 0x2 & 0x61          & 0x204          & 0xC2          & 0x208          & Add 0x4 to a1 \\
0x3c & addi a2, a2, 4    & 0x2          & 0x204          & \textbf{0x204} & 0x2 & 0x61          & 0x204          & 0xC2          & 0x208          & Add 0x4 to a2 \\
0x40 & bne a5, a7, -28   & 0x2          & 0x204          & 0x204          & 0x2 & 0x61          & 0x204          & 0xC2          & 0x208          & a5 $!=$ a7, so branch is taken, then PC is assigned 0x24 \\
0x24 & lw a4, 0(a5)      & 0x2          & 0x200          & 0x200          & 0x2 & \textbf{0x20} & 0x200          & 0x0           & 0x208          & Load value of address stored in a5, to a4 \\
0x28 & lw a6, 0(a1)      & 0x2          & 0x200          & 0x200          & 0x2 & 0x61          & 0x200          & \textbf{0x20} & 0x208          & Load value of address stored in a1, to a6 \\
0x2c & add a4, a4, a6    & 0x2          & 0x200          & 0x200          & 0x2 & 0x61          & 0x200          & \textbf{0x40} & 0x208          & Double the value stored in a4 \\
0x30 & sw a4, 0(a2)      & 0x2          & 0x200          & 0x200          & 0x2 & 0x61          & 0x200          & 0xC2          & 0x208          & Store 0x40 at 0x204 in memory \\
0x34 & addi a5, a5, 4    & 0x2          & 0x200          & 0x200          & 0x2 & 0x61          & \textbf{0x208} & 0xC2          & 0x208          & Add 0x4 to a5 \\
0x38 & addi a1, a1, 4    & 0x2          & \textbf{0x208} & 0x200          & 0x2 & 0x61          & 0x204          & 0xC2          & 0x208          & Add 0x4 to a1 \\
0x3c & addi a2, a2, 4    & 0x2          & 0x204          & \textbf{0x208} & 0x2 & 0x61          & 0x204          & 0xC2          & 0x208          & Add 0x4 to a2 \\
0x40 & bne a5, a7, -28   & 0x2          & 0x204          & 0x204          & 0x2 & 0x61          & 0x204          & 0xC2          & 0x208          & a5 $==$ a7, PC goes to 0x44 \\
0x44 & jalr zero, ra, 0  & 0x2          & 0x204          & 0x204          & 0x2 & 0x61          & 0x204          & 0xC2          & 0x208          & The PC goes to the address stored in ra, 0x0 \\

\hline
\end{tabular}
\end{adjustbox}
\caption{Program flow table}
\end{table}
\end{landscape}

\hspace*{1em} Explicitly explain how hazards occur.

\hspace*{1em} The final memory state is represented in the table below.

\begin{table}[H]
\centering
\label{tab:instructions-simple}
\vspace{0.3cm}
\renewcommand{\arraystretch}{1.6} % Increases row height for all rows
\begin{tabular}{|c|c|}
\hline
\rowcolor{blue!20}
\textbf{Address} & \textbf{Value} \\
\hline

0x200 & 0xC2 \\
0x204 & 0x40 \\
0x208 & 0x62 \\
0x20C & 0x00 \\
0x210 & 0x00 \\
\hline
\end{tabular}
\caption{Final memory state}
\end{table}

\newpage
\section {Procressor Design}
\subsection {Instruction Set Architecture}

For the processor that we are designing, we will have an instruction set based on 16 bit wide instructions.
There are 16 registers, all of them being 32 bit wide. The processor is of harvard architecture type.

• R0-R1: Return Registers
• R0-R4: Argument Registers (used to pass up to 4 function arguments)
• R5-R8: Temporary Registers (not preserved across function calls)
• R9-R12: Saved Registers (preserved across function calls)
• R13: Stack Pointer (SP)
• R14: Return Address Register (RA)
• R15: Program Counter (PC) (implicit, cannot be directly modified)

The operands are sign extended.

Arithmetic and logic instructions:
- SUM rd, rs1, rs2  ; rd = rs1 + rs2
- DIF rd, rs1, rs2  ; rd = rs1 - rs2
- SHL rd, rs1, rs2  ; rd = rs1 << rs2

Load from memory a 32bit value:
- MEL rd, rs1, imm ; rd = MEM[rs1 + imm] - Memory load
- MES rd, rs1, imm ; MEM[rs1 + imm] = rd - Memory store

Instruction to copy an immediate value to a register:
- SET rd, imm ; rd = imm

Define a conditional branch instruction having 1 register operand and 10 bit immediate
- BNZ rs1, imm ; if (rs1 != 0) PC = PC + imm * 2

Define an unconditional jump instruction having 1 register operand (read)
- GTO rs1 ; PC = rs1

Define a call instruction having 1 imm 9 bits
- CALL imm ; RA = PC + 2; PC = PC + imm * 2

Conditional branches, unconditional jumps, and calls in the instruction set have a branch delay slot
for a single instruction.

%% Deﬁne how the 16 registers have to be used by the programmer. In particular deﬁne how
%% arguments are passed on function calls for functions with up to 4 arguments. Deﬁne how
%% a to return from a function call and how the returned result of the function call can be
%% retrieved. Which registers are preserved/or potentially modiﬁed during a function call
%% https://computerscience.chemeketa.edu/armTutorial/Functions/CallingConvention.html

%% OPCODES IN NUMERICAL ORDER BY OPCODE + RV32I BASE INTEGER INSTRUCTIONS

%% Define a no operation - SUM R0, R0, 0




\newpage % keep bibliography on a new page
\bibliographystyle{plain}   % choose a style
\bibliography{ref}          % name of .bib file (no .bib extension)


\end{document}
