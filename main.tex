\documentclass{article}
\usepackage{graphicx}                            % Required for inserting images
\usepackage{booktabs}                            % Required for tables
\usepackage[a4paper, total={6in, 8in}]{geometry} % Adjust page margins
\usepackage{hyperref}                            % Clickable links
\usepackage{array}
\usepackage{multirow}
\usepackage{longtable}
\usepackage{xcolor}
\usepackage{tabularx}
\usepackage{colortbl}
\usepackage{adjustbox}
\usepackage{float}
\usepackage{listings}


\title{Project 1 Exectuion Platforms}
\author{Hamden Brini, Wilches Juan, Barau Elena, Marculescu Tudor}
\date{January 2025}

\begin{document}

\maketitle

\section{Introduction to RISC-V Instruction Set Architecture}

In this section we are focusing on a decomposition of RISC-V hex instruction into the ASM instruction.
The instruction format is determined based on the opcode, funct3 and funct7 fields. Table 1 depicts a
detailed translation of each instruction from it's hex code to it's format fields. Some of them
not used in certain instruction types, and are marked with a dash (-) in the table. The ultimate factor
that determines the instruction type is the "Type" column, which indicates instruction format label
R, I, S or SB.

\subsection{Program Instructions Decomposition}
\begin{table}[H]
\raggedright
\label{tab:instruction-decomposition}
\vspace{0.3cm}
\renewcommand{\arraystretch}{2}
\begin{adjustbox}{width=\textwidth, center}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|}
\hline
\rowcolor{blue!20}
\textbf{Address} & \textbf{Hex Code} & \textbf{Opcode (6:0)} & \textbf{rd (11:7)} & \textbf{funct3 (14:12)} & \textbf{rs1 (19:15)} & \textbf{rs2 (24:20)} & \textbf{funct7 (31:25)} & \textbf{imm[11:0] (31:20)} & \textbf{imm[11:5] (31:25)} & \textbf{imm[4:0] (11:7)} & \textbf{Type} \\
\hline
0x0  & 0x00050893 & 0010011 & 10001 & 000 & 01010 & - & - & 000000000000 & - & - & I \\
0x4  & 0x00068513 & 0010011 & 01010 & 000 & 01101 & - & - & 000000000000 & - & - & I \\
0x8  & 0x04088063 & 1100011 & - & 000 & 10001 & 00000 & - & - & 0000010 & 00000 & SB \\
0xc  & 0x04058263 & 1100011 & - & 000 & 01011 & 00000 & - & - & 0000010 & 00100 & SB \\
0x10 & 0x04060063 & 1100011 & - & 000 & 01100 & 00000 & - & - & 0000010 & 00000 & SB \\
0x14 & 0x04d05063 & 1100011 & - & 101 & 00000 & 01101 & - & - & 0000010 & 00000 & SB \\
0x18 & 0x00088793 & 0010011 & 01111 & 000 & 10001 & - & - & 000000000000 & - & - & I \\
0x1c & 0x00269713 & 0010011 & 01110 & 001 & 01101 & - & - & 000000000010 & - & - & I \\
0x20 & 0x00e888b3 & 0110011 & 10001 & 000 & 10001 & 01110 & 0000000 & - & 0000000 & 10001 & R \\
0x24 & 0x0007a703 & 0000011 & 01110 & 010 & 01111 & - & - & 000000000000 & - & - & I \\
0x28 & 0x0005a803 & 0000011 & 10000 & 010 & 01011 & - & - & 000000000000 & - & - & I \\
0x2c & 0x01070733 & 0110011 & 01110 & 000 & 01110 & 10000 & 0000000 & - & 0000000 & 01110 & R \\
0x30 & 0x00e62023 & 0100011 & - & 010 & 01100 & 01110 & - & - & 0000000 & 00000 & S \\
0x34 & 0x00478793 & 0010011 & 01111 & 000 & 01111 & - & - & 000000000100 & - & - & I \\
0x38 & 0x00458593 & 0010011 & 01011 & 000 & 01011 & - & - & 000000000100 & - & - & I \\
0x3c & 0x00460613 & 0010011 & 01100 & 000 & 01100 & - & - & 000000000100 & - & - & I \\
0x40 & 0xff1792e3 & 1100011 & - & 001 & 01111 & 10001 & - & - & 1111111 & 00101 & SB \\
0x44 & 0x00008067 & 1100111 & 00000 & 000 & 00001 & - & - & 000000000000 & - & - & I \\
0x48 & 0xfff00513 & 0010011 & 01010 & 000 & 00000 & - & - & 111111111111 & - & - & I \\
0x4c & 0x00008067 & 1100111 & 00000 & 000 & 00001 & - & - & 000000000000 & - & - & I \\
0x50 & 0xfff00513 & 0010011 & 01010 & 000 & 00000 & - & - & 111111111111 & - & - & I \\
0x54 & 0x00008067 & 1100111 & 00000 & 000 & 00001 & - & - & 000000000000 & - & - & I \\
\hline
\end{tabular}
\end{adjustbox}
\caption{Decomposition of Hex Codes to RISC-V Instruction Format}
\end{table}

A point to note is that the immediate fields for UJ and U type instructions are missing from Table 1.
This is because the provided program is missing them. There is also an overlap between the immediates
of S and SB type instructions, as they share the same positions in the instruction format. The table
head includes just the immediate fields for S out of simplicty, but in the case of SB, they were calculated
as depicted in the RISC-V specification from the Project 1 description \cite{PR1-SE201-21}.

\begin{table}[H]
\centering
\label{tab:instructions-simple}
\vspace{0.3cm}
\renewcommand{\arraystretch}{1.6} % Increases row height for all rows
\begin{tabular}{|c|c|c|c|}
\hline
\rowcolor{blue!20}
\textbf{Address} &
\textbf{Hex Code} &
\textbf{ASM Instruction (ABI)} &
\textbf{ASM Instruction (x-registers)} \\
\hline
0x0  & 0x00050893 & addi a7, a0, 0     & addi x17, x10, 0 \\
0x4  & 0x00068513 & addi a0, a3, 0     & addi x10, x13, 0 \\
0x8  & 0x04088063 & beq a7, zero, 64   & beq  x17, x0, 64 \\
0xc  & 0x04058263 & beq a1, zero, 68   & beq  x11, x0, 68 \\
0x10 & 0x04060063 & beq a2, zero, 64   & beq  x12, x0, 64 \\
0x14 & 0x04d05063 & bge zero, a3, 64   & bge  x0, x13, 64 \\
0x18 & 0x00088793 & addi a5, a7, 0     & addi x15, x17, 0 \\
0x1c & 0x00269713 & slli a4, a3, 2     & slli x14, x13, 2 \\
0x20 & 0x00e888b3 & add  a7, a7, a4    & add  x17, x17, x14 \\
0x24 & 0x0007a703 & lw   a4, 0(a5)     & lw   x14, 0(x15) \\
0x28 & 0x0005a803 & lw   a6, 0(a1)     & lw   x16, 0(x11) \\
0x2c & 0x01070733 & add  a4, a4, a6    & add  x14, x14, x16 \\
0x30 & 0x00e62023 & sw   a4, 0(a2)     & sw   x14, 0(x12)   \\
0x34 & 0x00478793 & addi a5, a5, 4     & addi x15, x15, 4   \\
0x38 & 0x00458593 & addi a1, a1, 4     & addi x11, x11, 4   \\
0x3c & 0x00460613 & addi a2, a2, 4     & addi x12, x12, 4   \\
0x40 & 0xff1792e3 & bne a5, a7, -28    & bne  x15, x17, -28 \\
0x44 & 0x00008067 & jalr zero, ra, 0   & jalr x0, x1, 0     \\
0x48 & 0xfff00513 & addi a0, zero, -1  & addi x10, x0, -1   \\
0x4c & 0x00008067 & jalr zero, ra, 0   & jalr x0, x1, 0     \\
0x50 & 0xfff00513 & addi a0, zero, -1  & addi x10, x0, -1   \\
0x54 & 0x00008067 & jalr zero, ra, 0   & jalr x0, x1, 0     \\
\hline
\end{tabular}
\caption{RISC-V Instructions with register numbers, symbolic names and addresses}
\end{table}

In order to better understand the provided program, Table 2 is introduced to map the hex codes with
their corresponding assembly instructions. As an overall view, the program is making use of RV32I instruction
set only. The registers are represented in both their symbolic names (ABI) and x-register numbers.
in order to facilitate the understanding of the program.

\subsection{Branch Delay Slot Concept}
The branch delay slot concept is interesting when discussing pipelined processors. Esentially, when
a branch instruction is taken, the instructions that were fetched after the branch instructions might
become invalid. To avoid this, the branch delay slot declares that the instruction immediately following
a branch instruction is always executed, regardless of whether the branch is taken or not. This helps to
mitigate the performance penalty associated with branch instructions that invalidate subsequent instructions
in the pipeline. As explained in \cite{Stack-overflow-branch-delay}: "The idea of the branch shadow or delay
slot is to recover a part of the clocks. If you declare that the instruction after a branch is always
executed then when a branch is taken, then the instruction in the decode slot also gets executed, while
the instruction in the fetch slot is discarded. Therefore one has a hole of time not two."

In terms of advantages and disadvantages, there are several points to consider. For disadvantages:

- Branch delay slots may create complications in code debugging, since the instruction in the delay slot
might have side effects, it may lead to an unexpected state of the registers and memory.

- It adds to the waiting time when trying to execute interruptions, since they will be deffered until
the delay slot instruction is executed. This is a problem in the case of real time systems.

- Software compatibility requirements dictate that an architecture may not change the number of delay
slots from one generation to the next. This inevitably requires that newer hardware implementations
contain extra hardware to ensure that the architectural behaviour is followed despite no longer being relevant.

Advantages of using branch delay slots include:

- Improved performance in pipelined architectures, since it helps to reduce the number of pipeline
stalls caused by branch instructions.

plus branch delay slots was initially a good ideea then a bad ideea

\subsection{Branch Instructions Analysis}
In order to understand better the provided program, it is useful to check the branch instructions and
where they lead to.

\begin{table}[H]
\centering
\caption{RISC-V Instructions with Addresses}
\label{tab:instructions-simple}
\vspace{0.3cm}
\renewcommand{\arraystretch}{1.6} % Increases row height for all rows
\begin{tabular}{|c|c|l|}
\hline
\rowcolor{blue!20}
\textbf{Address} & \textbf{Conditional branch} & \textbf{Branch to} \\
\hline

0x08 & beq a7, zero, 64  & 0x48: addi a0, zero, -1 \\
0x0c & beq a1, zero, 68  & 0x50: addi a0, zero, -1 \\
0x10 & beq a2, zero, 64  & 0x50: addi a0, zero, -1 \\
0x14 & bge zero, a3, 148 & 0x54: jalr zero, ra, 0  \\
0x40 & bne a5, a7, -28   & 0x24: lw a4, 0(a5)      \\

\hline
\end{tabular}
\end{table}

From the table above we can see that there are 4 first conditional branches, that being the
addresses 0x08, 0x0c, 0x10 and 0x14, which resemble input value checks. Considering the calling
convention for RISC-V, the registers a0-a7 are used for passing function arguments from the caller
to the callee. In this case, the supposition of input value checks is valid. The first three jump
to a return -1 in case the input values are 0, while the fourth one jumps to a return with the number
of elements to be processed, which would be less than or equal to 0.

The last conditional branch at address 0x40 is part of a loop. It checks whether the address stored
in register a5, used as a counter, is equal to the last address to be processed, which is stored in
register a7. If they are not equal, the program branches back to address 0x24 to continue processing
the next elements. If they are equal, the program continues to the return instruction.

\subsection{Program Functionality}

The program can be divided into three main parts: input validation, processing loop, and return value.
The input validation part checks if any of the first three caller arguments are 0. The arguments are
passed are actually pointers to the input and output arrays, so they are checked if they are null,
which would indicate an invalid memory access, therefore leading to a jump to the section of the
program corresponding to return -1. The fourth argument is the number of elements to be processed,
which is checked in the register a3 to see if it is less than or equal to 0. In case it is, the program
jumps to the section corresponding to return. In this case, it will return to the callee the value stored
in a0, which is actually a3, the number of elements to be processed.

The processing loop starts at address 0x18 and continues until the branch instruction at address 0x40
It consists of an initial setup for the loop counter in register a5 and for the final value of the
counter, which is stored in register a7. Register a7 will store the address of the last element to be processed from
one of the input arrays, calculated as the base address plus the number of elements multiplied by 4,
the size of each element. Because the elements are 4 bytes long, it can be extrapolated that the arrays
are made of 32-bit integers. The loop itself consists of loading the elements from both input arrays,
by using registers a5 and a1, which store the current addresses of the elements. Afterwards, the elements
are summed and stored in register a4, which is then stored in the output array location pointed by register a2.
Finally, the addresses in registers a5, a1 and a2 are incremented by 4 to point to the next elements
to be processed. The loop continues until the address in register a5 is equal to the address in register a7.
This is ensured by the branch if not equal instruction at address 0x40.

Finally, the return part is reached at address 0x44, where the program jumps back to the calle, using
the address stored in register ra. The return value is stored in register a0, which is equal to the
number of elements to be processed.

% \section{RISC-V Tool Chain}

% The program above is an assembly version of a C function that sums up the elements of two arrays. By
% following it's logic, we can recreate the C code as follows:

% \begin{lstlisting}[language=C]
% int addv(int *out, int *in1, int *in2, int n)
% {
%     if (in1 == 0)
%         return -1;
%     if (in2 == 0)
%         return -1;
%     if (out == 0)
%         return -1;
%     if (n <= 0)
%         return -1;

%     for (int i = 0; i < n; i++) {
%         out[i] = in1[i] + in2[i];
%     }

%     return 0;
% }
% \end{lstlisting}
% At first from the addresses 0x8 till 0x14 we have a series of checks to see if any of the pointers
% is null or if the number of elements is less than or equal to 0. We

\newpage % keep bibliography on a new page
\bibliographystyle{plain}   % choose a style
\bibliography{ref}          % name of .bib file (no .bib extension)


\end{document}
